 
Project NEMI: A Comprehensive Technical Overview and Implementation Guide
Document Version: 1.2
Date: October 12, 2025
Author: AI Agent
1. Executive Summary
This document provides a comprehensive and multi-layered overview of "Project NEMI," an advanced AI initiative focused on developing a dynamic, persistent, and self-organizing memory system. The project's architecture has evolved significantly from a simple data logger into a sophisticated, reinforcement-based knowledge graph that leverages a Retrieval-Augmented Generation (RAG) framework.
This guide details the project's conceptual evolution, from its initial goals to its current state, and provides a complete technical specification for version 4.2, including full source code and an analysis of its core components. The system is designed to mimic key aspects of human memory, including the ability to prioritize relevant information, establish connections between concepts, and gradually "forget" outdated or irrelevant data, thereby providing a robust foundation for a memory-driven AGI.
 
2. Architectural Evolution
The architecture of Project NEMI has progressed through several key versions, with each stage addressing the limitations of the previous one.
2.1. V0.0: Foundational Concept - The Simple Log
The project began with a straightforward objective: to create a persistent memory by logging all user and AI interactions in a structured JSON format.
•	Goals:
o	Memory: Store all interactions.
o	Dynamic: Allow the memory to grow.
o	Efficient: Use a simple, machine-readable format.
o	JSON: The chosen format for data storage.
•	Initial Structure: A single, flat JSON object where each interaction was keyed by a timestamp.
•	Critique: This foundational approach, while functional, suffered from critical limitations in scalability, data retrieval (chronological-only), and a lack of relational context between entries.
2.2. V2.0: A Multi-Layered Memory Architecture
To overcome the limitations of V0.0, the architecture was redesigned to function more like a relational database, separating concerns into four distinct but interconnected components.
1.	Sessions: Groups of interactions that provide episodic context to a conversation.
2.	Interactions: The enriched core dialogue, containing not just raw text but processed input with identified intents, entities, sentiment, and contextual links.
3.	Entities (The Knowledge Graph): A semantic memory store where the AI logs concepts, facts, and real-world entities separately from conversations. Each entity tracks every interaction where it was mentioned, creating an index for rapid, topic-based information retrieval.
4.	Users: A personalization layer to store user-specific data and preferences.
This structure transformed the memory from a linear log into a rich, interconnected graph of knowledge.
2.3. V3.0: Reinforcement-Based Memory and RAG
This version introduced the crucial concept of memory relevance, turning the static knowledge graph into a dynamic system that learns what information is important.
•	Theory: An AI's memory should be continuously re-weighted based on interaction. A relevance score is attached to every piece of information, and this score dictates what is recalled and what is forgotten.
•	Core Mechanisms:
1.	Relevance Scoring: Every interaction and entity is assigned a numerical score.
2.	Reinforcement (Reward): When a piece of memory is successfully used to provide context for a response, its relevance score is increased.
3.	Forgetting (Decay/Penalty): A decay mechanism periodically reduces the score of memories that have not been accessed recently, causing them to become less likely to be recalled.
4.	Retrieval-Augmented Generation (RAG): Before generating a response, the system queries its long-term memory for the highest-scoring information related to the current user input. This retrieved information is engineered into the final prompt, giving the AI a relevant "working memory."
5.	Pruning: To manage storage size, a script removes the interactions with the lowest scores once a certain threshold is reached.
 
3. Technical Specification and Implementation: Version 4.2
Version 4.2 is a mature PHP implementation of the V3.0 architecture, incorporating several key enhancements for robustness and functionality.
3.1. The "Brain Analogy": System Components
The project is structured into modular components, each with a distinct role:
•	index.php (Conscious Thought): The main orchestrator. It handles the user request, coordinates with the memory and AI client, builds the final prompt, and renders the UI.
•	MemoryManager.php (The Memory System): The core brain. It manages all memory operations: loading, saving, retrieving relevant context, updating relevance scores (reward/decay), and pruning old memories.
•	GeminiClient.php (Senses & Voice): The dedicated communicator. It handles all interactions with the Google Gemini API, including request formatting, error handling, and response parsing. It also manages dynamic tool selection.
•	config.php (Personality & Rules): A centralized configuration file defining API keys, file paths, and the constants that govern the memory logic (e.g., REWARD_SCORE, DECAY_SCORE).
3.2. Key Features and Enhancements in V4.2
•	URL Escaping Fix: The saveMemory() function in MemoryManager.php was updated to use the JSON_UNESCAPED_SLASHES flag, preventing the erroneous insertion of backslashes into URLs stored in the JSON files, thus ensuring data integrity.
•	Dynamic Tool Selection: The system can detect URLs in user input and dynamically instruct the AI model to use its googleSearch tool to analyze the content, allowing it to handle both general queries and URL analysis seamlessly.
•	User Feedback Loop: The UI includes "Good" and "Bad" response buttons. This feedback directly adjusts the relevance score of the interaction and the context used to generate it, creating a powerful human-in-the-loop reinforcement mechanism.
•	Advanced Memory Logic: The scoring system was enhanced with:
o	Novelty Bonus: New information that introduces a new entity gets an initial score boost.
o	Relationship Mapping: When entities are mentioned together, the system strengthens the recorded relationship between them.
o	Contextual Decay: Memories related to a recently discussed topic decay more slowly, preserving conversational context.
 
4. Complete Source Code (Version 4.2)
config.php
code PHP
downloadcontent_copy
expand_less
    <?php

// --- API Configuration ---
// IMPORTANT: For production, use environment variables instead of hardcoding keys.
define('GEMINI_API_KEY', 'YOUR_GEMINI_API_KEY_HERE'); // <-- REPLACE THIS
define('MODEL_ID', 'gemini-1.5-flash-latest');
define('API_ENDPOINT', 'generateContent');

// --- File Paths ---
define('DATA_DIR', __DIR__ . '/data');
define('INTERACTIONS_FILE', DATA_DIR . '/interactions.json');
define('ENTITIES_FILE', DATA_DIR . '/entities.json');
define('PROMPTS_LOG_FILE', DATA_DIR . '/prompts.json'); // Log file for prompts

// --- Memory Logic Configuration ---
define('REWARD_SCORE', 0.5);
define('DECAY_SCORE', 0.05);
define('INITIAL_SCORE', 1.0);
define('PRUNING_THRESHOLD', 500);
define('CONTEXT_TOKEN_BUDGET', 4000); // Approx. word count for context

// --- Advanced Scoring & Relationships ---
define('NOVELTY_BONUS', 0.3);        // Extra reward for interactions that introduce a new entity
define('RELATIONSHIP_STRENGTH_INCREMENT', 0.1); // How much to strengthen a link between entities
define('RECENT_TOPIC_DECAY_MODIFIER', 0.1); // Multiplier for decay (0.1 = 90% less decay)
define('USER_FEEDBACK_REWARD', 0.5);   // Score boost for a "Good Answer"
define('USER_FEEDBACK_PENALTY', -0.5); // Score penalty for a "Bad Answer"
  
GeminiClient.php
code PHP
downloadcontent_copy
expand_less
    <?php

class GeminiClient
{
    private string $apiKey;
    private string $modelId;
    private string $apiUrl;

    public function __construct()
    {
        $this->apiKey = GEMINI_API_KEY;
        $this->modelId = MODEL_ID;
        $this->apiUrl = "https://generativelanguage.googleapis.com/v1beta/models/{$this->modelId}:" . API_ENDPOINT . "?key={$this->apiKey}";
    }
    
    private function logPrompt(string $prompt, array $requestBody, string $rawResponse, ?string $error = null): void
    {
        if (!file_exists(PROMPTS_LOG_FILE)) {
            file_put_contents(PROMPTS_LOG_FILE, '[]');
        }
        $logData = json_decode(file_get_contents(PROMPTS_LOG_FILE), true);
        $decodedResponse = json_decode($rawResponse, true);

        $logEntry = [
            'timestamp' => date('c'),
            'request' => [
                'model' => $this->modelId,
                'tools' => array_keys(array_column($requestBody['tools'] ?? [], null, 0)),
                'prompt_text' => $prompt
            ],
            'response' => [
                'token_usage' => $decodedResponse['usageMetadata'] ?? null,
                'finish_reason' => $decodedResponse['candidates'][0]['finishReason'] ?? null,
                'response_text' => $decodedResponse['candidates'][0]['content']['parts'][0]['text'] ?? null,
            ],
            'error' => $error
        ];

        $logData[] = $logEntry;
        file_put_contents(PROMPTS_LOG_FILE, json_encode($logData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
    }

    public function generateResponse(string $prompt, array $enabledTools = []): string
    {
        if (empty($this->apiKey) || $this->apiKey === 'YOUR_GEMINI_API_KEY_HERE') {
            return "ERROR: Gemini API Key is not configured in config.php.";
        }
        
        $rawResponse = '';
        $requestBody = [];

        try {
            $requestBody = [
                'contents' => [['role' => 'user', 'parts' => [['text' => $prompt]]]],
                'generationConfig' => ['maxOutputTokens' => 8192],
            ];
            
            $requestTools = [];
            if (in_array('googleSearch', $enabledTools)) {
                $requestTools[] = ['googleSearch' => new stdClass()];
            }
            
            if (!empty($requestTools)) {
                 $requestBody['tools'] = $requestTools;
            }
            
            $ch = curl_init();
            curl_setopt($ch, CURLOPT_URL, $this->apiUrl);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($requestBody));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
            
            $rawResponse = curl_exec($ch);
            
            if (curl_errno($ch)) { throw new Exception("cURL Error: " . curl_error($ch)); }
            
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            if ($httpCode !== 200) { throw new Exception("API Error: HTTP {$httpCode}. Response: " . $rawResponse); }
            curl_close($ch);

            $decodedResponse = json_decode($rawResponse, true);
            if (json_last_error() !== JSON_ERROR_NONE) { throw new Exception("JSON Decode Error."); }

            $responseText = $decodedResponse['candidates'][0]['content']['parts'][0]['text'] ?? null;
            if ($responseText === null) {
                throw new Exception("Could not find text part in response, check for tool calls.");
            }
            
            $this->logPrompt($prompt, $requestBody, $rawResponse);
            return $responseText;

        } catch (Exception $e) {
            $this->logPrompt($prompt, $requestBody, $rawResponse, $e->getMessage());
            return "Error: " . $e->getMessage();
        }
    }
}
  
index.php
code PHP
downloadcontent_copy
expand_less
    <?php
ini_set('display_errors', 1);
error_reporting(E_ALL);

require_once 'config.php';
require_once 'MemoryManager.php';
require_once 'GeminiClient.php';

// Handle User Feedback
if ($_SERVER["REQUEST_METHOD"] == "GET" && isset($_GET['feedback'], $_GET['id'])) {
    $memory = new MemoryManager();
    $isGood = $_GET['feedback'] === 'good';
    $memory->applyFeedback($_GET['id'], $isGood);
    $memory->saveMemory();
    header("Location: index.php");
    exit();
}

function runCoreLogic(string $userInput): array
{
    $memory = new MemoryManager();
    $gemini = new GeminiClient();

    // Dynamic Tool Selection Logic
    $toolsToUse = ['googleSearch']; // Enable search by default
    $urlPattern = '/\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]/i';
    if (preg_match($urlPattern, $userInput)) {
        // The prompt guides the AI to use its search tool to analyze the URL
        $userInput .= "\n\n[SYSTEM NOTE: The user has provided a URL. Prioritize analyzing its content.]";
    }

    $recalled = $memory->getRelevantContext($userInput);
    $context = $recalled['context'];

    $systemPrompt = $memory->getTimeAwareSystemPrompt();
    $currentTime = "CURRENT_TIME: " . date('Y-m-d H:i:s T');
    $finalPrompt = "{$systemPrompt}\n\n---RECALLED CONTEXT---\n{$context}---END CONTEXT---\n\n{$currentTime}\n\nUser query: \"{$userInput}\"";

    $aiResponse = $gemini->generateResponse($finalPrompt, $toolsToUse);

    $newInteractionId = $memory->updateMemory($userInput, $aiResponse, $recalled['used_interaction_ids']);
    $memory->saveMemory();

    return [
        'userInput' => $userInput,
        'aiResponse' => $aiResponse,
        'context' => $context,
        'interactionId' => $newInteractionId
    ];
}

// --- Main Web Mode Execution ---
$userInput = '';
$aiResponse = '';
$context = '';
$interactionId = '';

if ($_SERVER["REQUEST_METHOD"] == "POST" && !empty($_POST['prompt'])) {
    $userInput = trim($_POST['prompt']);
    $result = runCoreLogic($userInput);
    $aiResponse = $result['aiResponse'];
    $context = $result['context'];
    $interactionId = $result['interactionId'];
}
?>
<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project NEMI v4.2</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #212529; color: #e9ecef; }
        .container { max-width: 800px; }
        .card { border-color: #495057; }
        .card-header { background-color: #343a40; }
        .feedback-buttons a { margin-right: 10px; }
    </style>
</head>
<body>
    <div class="container mt-5">
        <div class="text-center mb-4">
            <h1 class="display-4">Project NEMI <span class="badge bg-primary">v4.2</span></h1>
            <p class="lead text-muted">AI with Semantic Memory & URL Fix</p>
        </div>
        <div class="card bg-dark mb-3">
            <div class="card-body">
                <form action="index.php" method="post">
                    <textarea class="form-control bg-dark text-white mb-3" name="prompt" rows="3" placeholder="Ask anything or provide a URL to analyze..."><?= htmlspecialchars($userInput) ?></textarea>
                    <button type="submit" class="btn btn-primary w-100">Send</button>
                </form>
            </div>
        </div>
        <?php if ($_SERVER["REQUEST_METHOD"] == "POST"): ?>
            <div class="card bg-dark mb-3">
                <div class="card-header">Your Prompt</div>
                <div class="card-body"><p class="card-text"><?= nl2br(htmlspecialchars($userInput)) ?></p></div>
            </div>
            <div class="card bg-dark mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    AI Response
                    <div class="feedback-buttons">
                        <a href="?feedback=good&id=<?= urlencode($interactionId) ?>" class="btn btn-sm btn-outline-success">👍 Good</a>
                        <a href="?feedback=bad&id=<?= urlencode($interactionId) ?>" class="btn btn-sm btn-outline-danger">👎 Bad</a>
                    </div>
                </div>
                <div class="card-body"><p class="card-text"><?= nl2br(htmlspecialchars($aiResponse)) ?></p></div>
            </div>
            <div class="card bg-dark">
                <div class="card-header"><a class="text-decoration-none" data-bs-toggle="collapse" href="#debugCollapse">Debug: Recalled Context</a></div>
                <div class="collapse" id="debugCollapse">
                    <div class="card-body"><pre class="text-white-50 small"><code><?= htmlspecialchars($context) ?></code></pre></div>
                </div>
            </div>
        <?php endif; ?>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
  
MemoryManager.php
code PHP
downloadcontent_copy
expand_less
    <?php

class MemoryManager
{
    private array $interactions = [];
    private array $entities = [];

    public function __construct()
    {
        if (!is_dir(DATA_DIR)) {
            mkdir(DATA_DIR, 0775, true);
        }
        $this->loadMemory();
    }

    private function loadMemory(): void
    {
        $this->interactions = file_exists(INTERACTIONS_FILE) ? json_decode(file_get_contents(INTERACTIONS_FILE), true) : [];
        $this->entities = file_exists(ENTITIES_FILE) ? json_decode(file_get_contents(ENTITIES_FILE), true) : [];
    }

    public function saveMemory(): void
    {
        ksort($this->interactions);
        ksort($this->entities);

        // **FIX IMPLEMENTED HERE**: Added JSON_UNESCAPED_SLASHES to prevent `\` in URLs.
        $options = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES;

        file_put_contents(INTERACTIONS_FILE, json_encode($this->interactions, $options));
        file_put_contents(ENTITIES_FILE, json_encode($this->entities, $options));
    }

    public function getTimeAwareSystemPrompt(): string
    {
        return "**PRIMARY DIRECTIVE: YOU ARE A HELPFUL, TIME-AWARE ASSISTANT.**\n\n" .
            "**RULES OF OPERATION:**\n" .
            "1.  **ANALYZE TIMESTAMPS:** You will be given a `CURRENT_TIME` and `RECALLED_CONTEXT`. Use this to understand the history of events.\n" .
            "2.  **CALCULATE RELATIVE TIME:** Interpret expressions like 'yesterday' against the provided `CURRENT_TIME`.\n\n" .
            "**TOOL EXECUTION MANDATE:**\n" .
            "3.  **DIRECTLY USE TOOLS:** You have a `googleSearch` tool. Your primary goal is to use this tool to directly answer the user's question. **DO NOT describe that you are going to use a tool.** Execute it and provide the final answer based on its output.\n" .
            "4.  **FULFILL THE REQUEST:** If the user provides a URL, use your search ability to access its content and provide a summary. If they ask a general question, use search to find the answer.";
    }

    private function extractEntities(string $text): array
    {
        // This function is simple; a more advanced version would use NLP libraries.
        $text = strtolower($text);
        // Prevent splitting URLs by common delimiters
        $text = preg_replace('/https?:\/\/[^\s]+/', ' ', $text);
        $words = preg_split('/[\s,\.\?\!\[\]:]+/', $text);
        $stopWords = ['a', 'an', 'the', 'is', 'in', 'it', 'of', 'for', 'on', 'what', 'were', 'my', 'that', 'we', 'to', 'user', 'note', 'system', 'please'];
        return array_filter(array_unique($words), fn($word) => !in_array($word, $stopWords) && strlen($word) > 3);
    }
    
    private function normalizeAndExpandEntities(array $baseEntities): array
    {
        $expanded = $baseEntities;
        foreach ($baseEntities as $entityKey) {
            if (isset($this->entities[$entityKey]['relationships'])) {
                $expanded = array_merge($expanded, array_keys($this->entities[$entityKey]['relationships']));
            }
        }
        return array_unique($expanded);
    }

    public function getRelevantContext(string $userInput): array
    {
        $inputEntities = $this->extractEntities($userInput);
        $searchEntities = $this->normalizeAndExpandEntities($inputEntities);
        $relevantInteractionIds = [];

        foreach ($searchEntities as $entityKey) {
            if (isset($this->entities[$entityKey])) {
                $relevantInteractionIds = array_merge($relevantInteractionIds, $this->entities[$entityKey]['mentioned_in']);
            }
        }
        
        $uniqueInteractionIds = array_unique($relevantInteractionIds);
        $relevantMemories = [];
        foreach ($uniqueInteractionIds as $id) {
            if (isset($this->interactions[$id])) {
                $relevantMemories[$id] = $this->interactions[$id];
            }
        }

        uasort($relevantMemories, fn($a, $b) => ($b['relevance_score'] ?? 1.0) <=> ($a['relevance_score'] ?? 1.0));

        $context = '';
        $tokenCount = 0;
        $usedInteractionIds = [];
        
        foreach ($relevantMemories as $id => $memory) {
            $timestamp = date('Y-m-d H:i:s', strtotime($memory['timestamp']));
            $memoryText = "[On {$timestamp}] User: '{$memory['user_input_raw']}'. You: '{$memory['ai_output']}'.\n";
            $memoryTokenCount = str_word_count($memoryText);

            if ($tokenCount + $memoryTokenCount <= CONTEXT_TOKEN_BUDGET) {
                $context .= $memoryText;
                $tokenCount += $memoryTokenCount;
                $usedInteractionIds[] = $id;
            } else {
                break;
            }
        }

        return [
            'context' => empty($context) ? "No relevant memories found.\n" : $context,
            'used_interaction_ids' => $usedInteractionIds
        ];
    }
    
    public function updateMemory(string $userInput, string $aiOutput, array $usedInteractionIds): string
    {
        $recentEntities = [];
        foreach ($usedInteractionIds as $id) {
            if (isset($this->interactions[$id])) {
                $this->interactions[$id]['relevance_score'] += REWARD_SCORE;
                $this->interactions[$id]['last_accessed'] = date('c');
                if (isset($this->interactions[$id]['processed_input']['keywords'])) {
                    $recentEntities = array_merge($recentEntities, $this->interactions[$id]['processed_input']['keywords']);
                }
            }
        }
        $recentEntities = array_unique($recentEntities);

        foreach ($this->interactions as &$interaction) {
            $keywords = $interaction['processed_input']['keywords'] ?? [];
            $isRelatedToRecentTopic = !empty(array_intersect($keywords, $recentEntities));
            $decay = $isRelatedToRecentTopic ? DECAY_SCORE * RECENT_TOPIC_DECAY_MODIFIER : DECAY_SCORE;
            $interaction['relevance_score'] -= $decay;
        }

        $newId = uniqid('int_', true);
        $keywords = $this->extractEntities($userInput);
        
        $this->interactions[$newId] = [
            'timestamp' => date('c'),
            'user_input_raw' => $userInput,
            'processed_input' => ['keywords' => $keywords],
            'ai_output' => $aiOutput,
            'relevance_score' => INITIAL_SCORE,
            'last_accessed' => date('c'),
            'context_used_ids' => $usedInteractionIds
        ];
        
        $this->updateEntitiesFromInteraction($keywords, $newId);
        $this->pruneMemory();
        
        return $newId;
    }

    private function updateEntitiesFromInteraction(array $keywords, string $interactionId): void
    {
        $isNovel = false;
        foreach ($keywords as $keyword) {
            $entityKey = strtolower($keyword);
            if (!isset($this->entities[$entityKey])) {
                $isNovel = true;
                $this->entities[$entityKey] = [
                    'name' => $keyword, 'type' => 'Concept', 'access_count' => 0, 'relevance_score' => INITIAL_SCORE,
                    'mentioned_in' => [], 'relationships' => []
                ];
            }
            $this->entities[$entityKey]['access_count']++;
            $this->entities[$entityKey]['relevance_score'] += REWARD_SCORE;
            if (!in_array($interactionId, $this->entities[$entityKey]['mentioned_in'])) {
                $this->entities[$entityKey]['mentioned_in'][] = $interactionId;
            }
        }
        
        if ($isNovel) {
            $this->interactions[$interactionId]['relevance_score'] += NOVELTY_BONUS;
        }

        if (count($keywords) > 1) {
            foreach ($keywords as $k1) {
                foreach ($keywords as $k2) {
                    if ($k1 !== $k2) {
                        $this->entities[$k1]['relationships'][$k2] = ($this->entities[$k1]['relationships'][$k2] ?? 0) + RELATIONSHIP_STRENGTH_INCREMENT;
                    }
                }
            }
        }
    }

    public function applyFeedback(string $interactionId, bool $isGood): void
    {
        if (!isset($this->interactions[$interactionId])) return;

        $adjustment = $isGood ? USER_FEEDBACK_REWARD : USER_FEEDBACK_PENALTY;
        
        $this->interactions[$interactionId]['relevance_score'] += $adjustment;

        $contextIds = $this->interactions[$interactionId]['context_used_ids'] ?? [];
        foreach ($contextIds as $id) {
            if (isset($this->interactions[$id])) {
                $this->interactions[$id]['relevance_score'] += $adjustment / 2;
            }
        }
    }
    
    private function pruneMemory(): void
    {
        if (count($this->interactions) > PRUNING_THRESHOLD) {
            uasort($this->interactions, fn($a, $b) => ($a['relevance_score'] ?? 1.0) <=> ($b['relevance_score'] ?? 1.0));
            $this->interactions = array_slice($this->interactions, count($this->interactions) - PRUNING_THRESHOLD, null, true);
        }
    }
}
  
 
 
Nota Bene: Rules for Future Document Updates
AI and/or agents must adhere to the following rules to maintain the consistency and integrity of this document.
1.	Strict Versioning: All modifications, regardless of size, mandate a version increment.
o	Patch (e.g., 4.2 -> 4.2.1): Typographical corrections, code comments, non-functional changes.
o	Minor (e.g., 4.2 -> 4.3): New features, changes in logic, enhancements that are backward-compatible.
o	Major (e.g., 4.0 -> 5.0): Significant architectural changes or rewrites that are not backward-compatible.
2.	Mandatory Changelog: Every new version must be documented in a "Revision History" section added to the top of the document. The entry must include the new version number, date, author, and a concise, bulleted list of all changes made.
3.	Code Synchronization: The source code presented within this document must be an exact and complete representation of the functional source code files. Any change to a .php file must be immediately and accurately reflected in its corresponding code block herein.
4.	Preserve Architecture: New functionality must be integrated into the existing "Brain Analogy" component structure (index.php, MemoryManager.php, GeminiClient.php, config.php). If a new component is necessary, its purpose and interaction with the existing components must be explicitly defined.
5.	Centralize Configuration: All new constants, thresholds, or configurable parameters must be added exclusively to config.php. No hardcoded "magic values" are permitted in the logic of other files.
6.	Maintain Structural Integrity: The existing numbered heading structure of this document must be preserved. New content should be added as subsections within the relevant existing section. Do not alter the primary document flow.
7.	Direct and Specific Language: All descriptions of changes must be technical, direct, and unambiguous. Clearly state what was changed, why it was changed, and reference the specific function or component affected.

